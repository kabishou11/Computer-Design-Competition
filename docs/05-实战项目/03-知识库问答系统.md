# 知识库问答系统

## 1. 项目概述

构建一个基于私有知识库的智能问答系统，支持文档上传、向量检索、问答交互。

## 2. 系统架构

```
┌─────────────────────────────────────────────────────────┐
│                   知识库问答系统                          │
├─────────────────────────────────────────────────────────┤
│                                                         │
│   ┌─────────────┐  ┌─────────────┐  ┌─────────────┐   │
│   │  文档上传   │  │  URL导入    │  │  API接入   │   │  ← 数据采集
│   └─────────────┘  └─────────────┘  └─────────────┘   │
│                                                         │
│   ┌─────────────────────────────────────────────────┐   │
│   │              文档处理管道                        │   │
│   │  ┌─────┐ ┌─────┐ ┌─────┐ ┌─────┐ ┌─────┐      │   │
│   │  │解析 │ │清洗 │ │分块 │ │向量化│ │存储 │      │   │
│   │  └─────┘ └─────┘ └─────┘ └─────┘ └─────┘      │   │
│   └─────────────────────────────────────────────────┘   │
│                                                         │
│   ┌─────────────────────────────────────────────────┐   │
│   │              问答引擎                            │   │
│   │  ┌─────┐ ┌─────┐ ┌─────┐ ┌─────┐ ┌─────┐      │   │
│   │  │召回 │ │重排 │ │融合 │ │生成 │ │返回 │      │   │
│   │  └─────┘ └─────┘ └─────┘ └─────┘ └─────┘      │   │
│   └─────────────────────────────────────────────────┘   │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

## 3. 核心实现

### 3.1 文档处理管道

```python
from pathlib import Path
from typing import List, Dict
import asyncio

class DocumentProcessor:
    """文档处理器"""

    SUPPORTED_FORMATS = ['.pdf', '.docx', '.txt', '.md', '.html', '.csv']

    def __init__(self, chunk_size: int = 512, chunk_overlap: int = 50):
        self.chunk_size = chunk_size
        self.chunk_overlap = chunk_overlap
        self.chunker = SemanticChunker()  # 或其他分块器

    def process_directory(self, directory: str) -> List[Dict]:
        """处理目录"""
        docs = []
        for path in Path(directory).rglob('*'):
            if path.is_file() and path.suffix in self.SUPPORTED_FORMATS:
                content = self.load_document(path)
                chunks = self.chunker.chunk(content)
                docs.extend(chunks)

        return docs

    def load_document(self, file_path: Path) -> Dict:
        """加载文档"""
        suffix = file_path.suffix.lower()

        if suffix == '.pdf':
            return self._load_pdf(file_path)
        elif suffix == '.docx':
            return self._load_docx(file_path)
        elif suffix == '.txt':
            return self._load_txt(file_path)
        elif suffix == '.md':
            return self._load_md(file_path)
        else:
            return {"content": "", "metadata": {}}

    def _load_pdf(self, file_path: Path) -> Dict:
        """加载PDF"""
        import pdfplumber

        with pdfplumber.open(file_path) as pdf:
            text = ""
            for page in pdf.pages:
                text += page.extract_text() + "\n"

        return {
            "content": text,
            "metadata": {
                "source": str(file_path),
                "type": "pdf",
                "pages": len(pdf.pages)
            }
        }

    def _load_docx(self, file_path: Path) -> Dict:
        """加载Word"""
        from docx import Document

        doc = Document(file_path)
        text = "\n".join([p.text for p in doc.paragraphs])

        return {
            "content": text,
            "metadata": {
                "source": str(file_path),
                "type": "docx"
            }
        }

    def chunk_document(self, content: str, metadata: Dict) -> List[Dict]:
        """分块"""
        # 使用语义分块
        chunks = self.chunker.chunk(content)

        return [
            {
                "content": chunk,
                "metadata": {
                    **metadata,
                    "chunk_id": i,
                    "chunk_length": len(chunk)
                }
            }
            for i, chunk in enumerate(chunks)
        ]
```

### 3.2 向量索引管理

```python
class VectorIndexManager:
    """向量索引管理器"""

    def __init__(self, embedding_model: str = "BAAI/bge-large-zh"):
        from sentence_transformers import SentenceTransformer

        self.encoder = SentenceTransformer(embedding_model)
        self.index = FAISSIndex()  # 或 MilvusIndex, ChromaIndex
        self.doc_store = {}  # 文档存储

    def add_documents(self, documents: List[Dict], batch_size: int = 32):
        """添加文档"""
        texts = [doc["content"] for doc in documents]
        metadata = [doc["metadata"] for doc in documents]

        # 批量编码
        embeddings = self.encoder.encode(texts, batch_size=batch_size)

        # 添加到索引
        self.index.add(embeddings, metadata)

        # 更新文档存储
        for i, meta in enumerate(metadata):
            self.doc_store[meta.get("chunk_id", i)] = {
                "content": texts[i],
                "metadata": meta
            }

    def search(
        self,
        query: str,
        top_k: int = 5,
        filter_metadata: Dict = None
    ) -> List[Dict]:
        """搜索"""
        # 编码查询
        query_embedding = self.encoder.encode([query])

        # 检索
        results = self.index.search(query_embedding, top_k)

        # 过滤
        if filter_metadata:
            results = self._filter_by_metadata(results, filter_metadata)

        # 检索文档内容
        enriched = []
        for r in results:
            chunk_id = r["metadata"].get("chunk_id", r["id"])
            doc = self.doc_store.get(chunk_id, {})
            enriched.append({
                **r,
                "content": doc.get("content", ""),
                "metadata": doc.get("metadata", {})
            })

        return enriched

    def save(self, path: str):
        """保存"""
        self.index.save(path)
        import json
        with open(f"{path}/docs.json", "w") as f:
            json.dump(self.doc_store, f)

    def load(self, path: str):
        """加载"""
        self.index.load(path)
        import json
        with open(f"{path}/docs.json", "r") as f:
            self.doc_store = json.load(f)
```

### 3.3 完整问答系统

```python
class KnowledgeBaseQA:
    """知识库问答系统"""

    def __init__(
        self,
        embedding_model: str,
        llm_model,
        reranker_model: str = None
    ):
        self.processor = DocumentProcessor()
        self.index_manager = VectorIndexManager(embedding_model)
        self.llm = llm_model

        if reranker_model:
            self.reranker = CrossEncoderReranker(reranker_model)

    def build_knowledge_base(self, source: str):
        """构建知识库"""
        # 处理文档
        if Path(source).is_dir():
            documents = self.processor.process_directory(source)
        else:
            content = self.processor.load_document(Path(source))
            documents = self.processor.chunk_document(
                content["content"],
                content["metadata"]
            )

        # 添加到索引
        self.index_manager.add_documents(documents)

        return f"知识库构建完成，包含 {len(documents)} 个文档块"

    def ask(
        self,
        question: str,
        top_k: int = 5,
        use_rerank: bool = True,
        stream: bool = False
    ) -> Dict:
        """问答"""
        # 1. 检索
        initial_results = self.index_manager.search(question, top_k=top_k * 2)

        # 2. 重排序
        if use_rerank and hasattr(self, 'reranker'):
            reranked = self.reranker.rerank(question, initial_results)
        else:
            reranked = initial_results[:top_k]

        # 3. 提取上下文
        context = "\n".join([r["content"] for r in reranked[:top_k]])

        # 4. 生成回答
        answer = self._generate_answer(question, context, stream=stream)

        return {
            "answer": answer,
            "sources": [
                {
                    "content": r["content"][:200] + "...",
                    "metadata": r["metadata"],
                    "score": r.get("score", 0)
                }
                for r in reranked[:3]
            ]
        }

    def _generate_answer(
        self,
        question: str,
        context: str,
        stream: bool = False
    ) -> str:
        """生成回答"""
        prompt = f"""
基于以下知识库内容回答问题。如果无法从内容中找到答案，请说明。

知识库内容：
{context}

问题：{question}

请给出准确的回答，并注明信息来源。
"""

        if stream:
            return self.llm.generate_stream(prompt)
        else:
            return self.llm.generate(prompt)

    def evaluate(self, test_questions: List[Dict]) -> Dict:
        """评估"""
        from ragas.metrics import faithfulness, answer_relevancy

        results = []
        for q in test_questions:
            result = self.ask(q["question"])
            results.append({
                "question": q["question"],
                "answer": result["answer"],
                "ground_truth": q.get("answer"),
                "contexts": [s["content"] for s in result["sources"]]
            })

        # 计算指标
        return {
            "total_questions": len(results),
            "answered": len([r for r in results if r["answer"]]),
            "sample_results": results[:5]
        }
```

## 4. API服务

```python
# api.py
from fastapi import FastAPI, UploadFile, File, Form
from typing import Optional

app = FastAPI(title="知识库问答API")

qa_system = KnowledgeBaseQA(
    embedding_model="BAAI/bge-large-zh",
    llm_model=LocalLLM("Qwen/Qwen2.5-7B-Instruct")
)

@app.post("/kb/build")
async def build_knowledge_base(source: str = Form(...)):
    """构建知识库"""
    return {"status": "success", "message": qa_system.build_knowledge_base(source)}

@app.post("/kb/add-file")
async def add_document(file: UploadFile = File(...)):
    """添加文档"""
    content = await file.read()
    # 处理文档...
    return {"status": "success"}

@app.post("/qa")
async def question_answering(
    question: str = Form(...),
    top_k: int = Form(5),
    use_rerank: bool = Form(True)
):
    """问答"""
    result = qa_system.ask(
        question=question,
        top_k=top_k,
        use_rerank=use_rerank
    )
    return result

@app.get("/kb/search")
async def search_knowledge(query: str, top_k: int = 5):
    """搜索知识库"""
    results = qa_system.index_manager.search(query, top_k)
    return {"results": results}
```

## 5. 前端界面

```python
# frontend.py
import gradio as gr

def create_qa_interface(qa_system):
    """创建问答界面"""

    with gr.Blocks() as interface:
        gr.Markdown("# 📚 知识库问答系统")

        with gr.Row():
            with gr.Column(scale=2):
                question = gr.Textbox(
                    label="您的问题",
                    placeholder="请输入您想了解的问题..."
                )
                top_k = gr.Slider(
                    minimum=1,
                    maximum=20,
                    value=5,
                    step=1,
                    label="检索数量"
                )
                use_rerank = gr.Checkbox(
                    value=True,
                    label="使用重排序"
                )
                ask_btn = gr.Button("提问", variant="primary")

            with gr.Column(scale=3):
                answer = gr.Markdown(label="回答")
                sources = gr.JSON(label="参考来源")

        with gr.Row():
            with gr.Accordion("知识库管理", open=False):
                file_input = gr.File(
                    label="上传文档",
                    file_types=[".pdf", ".txt", ".docx", ".md"]
                )
                build_btn = gr.Button("构建知识库", variant="secondary")
                build_status = gr.Markdown()

        ask_btn.click(
            qa_system.ask,
            inputs=[question, top_k, use_rerank],
            outputs=[answer, sources]
        )

    return interface.launch()
```

## 6. 项目评估

| 评估项 | 指标 | 目标 |
|-------|------|------|
| 检索质量 | Recall@K | >0.8 |
| 回答准确率 | 人工评估 | >85% |
| 响应时间 | P95延迟 | <2s |
| 覆盖率 | 问题覆盖率 | >90% |
