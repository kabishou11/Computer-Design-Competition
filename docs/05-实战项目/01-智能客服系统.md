# 智能客服系统

## 1. 项目概述

### 1.1 项目背景

智能客服是LLM最成熟的应用场景之一，通过RAG技术将企业知识库与大模型结合，实现自动问答。

### 1.2 系统架构

```
┌─────────────────────────────────────────────────────────┐
│                    智能客服系统架构                       │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  ┌─────────────┐    ┌─────────────┐                     │
│  │   Web界面   │    │   微信/APP  │  ← 接入层          │
│  └──────┬──────┘    └──────┬──────┘                     │
│         │                   │                            │
│         └─────────┬─────────┘                            │
│                   ▼                                      │
│         ┌─────────────────────┐                           │
│         │     API Gateway     │  ← 请求路由               │
│         └─────────┬───────────┘                           │
│                   ▼                                      │
│  ┌─────────────────────────────────────┐                │
│  │         业务处理层                   │                │
│  │  ┌─────────┐ ┌─────────┐ ┌───────┐ │                │
│  │  │ 对话管理 │ │ 意图识别 │ │ RAG  │ │                │
│  │  └─────────┘ └─────────┘ └───────┘ │                │
│  └─────────────────────────────────────┘                │
│                   ▼                                      │
│  ┌─────────────────────────────────────┐                │
│  │         知识库层                     │                │
│  │  ┌─────────┐ ┌─────────┐ ┌───────┐ │                │
│  │  │文档处理  │ │向量索引 │ │知识图谱│ │                │
│  │  └─────────┘ └─────────┘ └───────┘ │                │
│  └─────────────────────────────────────┘                │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

## 2. 核心模块实现

### 2.1 对话管理

```python
from typing import Dict, List, Optional
from dataclasses import dataclass, field
from datetime import datetime

@dataclass
class Conversation:
    """对话会话"""
    session_id: str
    user_id: str
    messages: List[Dict] = field(default_factory=list)
    state: str = "active"  # active, pending, closed
    intent: str = None
    created_at: datetime = field(default_factory=datetime.now)
    updated_at: datetime = field(default_factory=datetime.now)

class ConversationManager:
    """对话管理器"""

    def __init__(self, max_history: int = 10):
        self.sessions: Dict[str, Conversation] = {}
        self.max_history = max_history

    def create_session(self, user_id: str) -> str:
        """创建会话"""
        session_id = f"{user_id}_{datetime.now().timestamp()}"
        self.sessions[session_id] = Conversation(
            session_id=session_id,
            user_id=user_id
        )
        return session_id

    def add_message(self, session_id: str, role: str, content: str):
        """添加消息"""
        if session_id not in self.sessions:
            raise ValueError("Session not found")

        session = self.sessions[session_id]
        session.messages.append({
            "role": role,
            "content": content,
            "timestamp": datetime.now().isoformat()
        })

        # 限制历史长度
        if len(session.messages) > self.max_history:
            # 摘要早期消息
            session.messages = self._summarize_and_keep(
                session.messages,
                keep_last=5
            )

    def get_context(self, session_id: str) -> List[Dict]:
        """获取对话上下文"""
        return self.sessions.get(session_id, {}).get("messages", [])

    def _summarize_and_keep(
        self,
        messages: List[Dict],
        keep_last: int
    ) -> List[Dict]:
        """摘要并保留最近消息"""
        # 保留最近消息
        recent = messages[-keep_last:]

        # 摘要早期消息
        if len(messages) > keep_last:
            early = messages[:-keep_last]
            summary = self._summarize_messages(early)
            summarized = [{
                "role": "system",
                "content": f"[历史摘要]{summary}"
            }]
            return summarized + recent

        return messages

    def _summarize_messages(self, messages: List[Dict]) -> str:
        """摘要消息"""
        text = "\n".join([m["content"] for m in messages])
        # 调用LLM摘要
        return f"[摘要]{text[:200]}..."
```

### 2.2 意图识别

```python
class IntentRecognizer:
    """意图识别器"""

    def __init__(self, llm, intents: List[Dict]):
        """
        intents: [
            {"name": "product_inquiry", "examples": ["这个产品多少钱", "价格是多少"]},
            {"name": "order_status", "examples": ["我的订单到哪了", "查一下物流"]},
            {"name": "refund", "examples": ["我想退货", "怎么退款"]},
        ]
        """
        self.llm = llm
        self.intents = intents

    def recognize(self, query: str) -> Dict:
        """识别意图"""
        intent_descriptions = "\n".join([
            f"- {i['name']}: {', '.join(i['examples'][:3])}"
            for i in self.intents
        ])

        prompt = f"""
请识别以下用户查询的意图：

用户查询：{query}

可用意图：
{intent_descriptions}

请JSON格式返回：
{{
    "intent": "意图名称",
    "confidence": 0.0-1.0,
    "entities": ["关键实体"]
}}
"""
        result = self.llm.generate(prompt)
        return json.loads(result)

    def extract_entities(self, query: str) -> List[Dict]:
        """提取实体"""
        prompt = f"""
从以下查询中提取关键实体：

查询：{query}

实体类型：
- 产品名称
- 订单号
- 日期
- 金额

JSON格式：
"""
        result = self.llm.generate(prompt)
        return json.loads(result)
```

### 2.3 完整客服Agent

```python
class CustomerServiceAgent:
    """客服Agent"""

    def __init__(
        self,
        llm,
        conversation_manager: ConversationManager,
        intent_recognizer: IntentRecognizer,
        knowledge_retriever: BaseRetriever
    ):
        self.llm = llm
        self.conv_manager = conversation_manager
        self.intent_recognizer = intent_recognizer
        self.retriever = knowledge_retriever

    def chat(self, session_id: str, user_message: str) -> str:
        """处理对话"""
        # 1. 添加用户消息
        self.conv_manager.add_message(session_id, "user", user_message)

        # 2. 获取对话历史
        history = self.conv_manager.get_context(session_id)

        # 3. 意图识别
        intent_result = self.intent_recognizer.recognize(user_message)

        # 4. 检索知识库
        if intent_result["confidence"] > 0.6:
            relevant_docs = self.retriever.retrieve(
                user_message,
                filter_intent=intent_result["intent"]
            )
        else:
            relevant_docs = self.retriever.retrieve(user_message)

        # 5. 生成回答
        response = self._generate_response(
            user_message,
            history,
            relevant_docs,
            intent_result
        )

        # 6. 添加助手消息
        self.conv_manager.add_message(session_id, "assistant", response)

        return response

    def _generate_response(
        self,
        query: str,
        history: List[Dict],
        relevant_docs: List[Dict],
        intent_result: Dict
    ) -> str:
        """生成回答"""
        context = "\n".join([d["text"] for d in relevant_docs[:3]])

        prompt = f"""
你是专业的客服人员，请根据知识库信息回答用户问题。

当前对话历史：
{chr(10).join([f"{m['role']}: {m['content']}" for m in history[-5:]])}

识别到的意图：{intent_result['intent']}

相关知识：
{context}

用户问题：{query}

要求：
1. 礼貌、专业
2. 直接回答问题
3. 如需更多信息，请礼貌询问
4. 如知识库没有相关信息，请说明并建议其他渠道

回答：
"""
        return self.llm.generate(prompt)
```

## 3. 部署与优化

### 3.1 部署架构

```python
# main.py - FastAPI服务入口
from fastapi import FastAPI, WebSocket
from contextlib import asynccontextmanager

app = FastAPI(title="智能客服系统")

@asynccontextmanager
async def lifespan(app: FastAPI):
    # 初始化系统
    conversation_manager = ConversationManager()
    intent_recognizer = IntentRecognizer(llm, intents)
    knowledge_retriever = HybridRetriever(knowledge_base)
    agent = CustomerServiceAgent(
        llm, conversation_manager, intent_recognizer, knowledge_retriever
    )

    yield {"agent": agent}

@app.websocket("/ws/chat")
async def websocket_chat(websocket: WebSocket):
    """WebSocket对话"""
    await websocket.accept()

    session_id = None
    try:
        while True:
            data = await websocket.receive_json()
            session_id = data.get("session_id") or agent.create_session(data["user_id"])
            response = agent.chat(session_id, data["message"])

            await websocket.send_json({
                "session_id": session_id,
                "response": response
            })
    except Exception as e:
        await websocket.send_json({"error": str(e)})
```

### 3.2 性能优化

```python
class CachingLayer:
    """缓存层"""

    def __init__(self, redis_client):
        self.redis = redis_client
        self.cache_ttl = 3600  # 1小时

    def get_cached_response(self, query: str) -> Optional[str]:
        """获取缓存回答"""
        key = f"response:{hash(query)}"
        return self.redis.get(key)

    def cache_response(self, query: str, response: str):
        """缓存回答"""
        key = f"response:{hash(query)}"
        self.redis.setex(key, self.cache_ttl, response)

    def get_cached_knowledge(self, query: str) -> Optional[List[Dict]]:
        """缓存检索结果"""
        key = f"knowledge:{hash(query)}"
        return json.loads(self.redis.get(key) or "null")

    def cache_knowledge(self, query: str, results: List[Dict]):
        """存储检索结果"""
        key = f"knowledge:{hash(query)}"
        self.redis.setex(key, self.cache_ttl, json.dumps(results))
```

## 4. 项目评估指标

| 指标 | 目标值 | 说明 |
|-----|-------|------|
| 回答准确率 | >85% | 用户满意度评分 |
| 首次响应时间 | <1s | 用户体验 |
| 问题解决率 | >70% | 无需转人工比例 |
| 对话轮数 | <5轮 | 效率指标 |

## 5. 扩展建议

- 添加多轮对话确认
- 集成转人工机制
- 添加情感分析
- 支持语音输入
- 统计分析面板
